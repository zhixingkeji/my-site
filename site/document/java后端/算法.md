## 一. 算法简介

算法学习路线

![preview](https://pic4.zhimg.com/v2-3e2599bc0ca77c5f609fb62e15d9755f_r.jpg)





### 1.1 算法概念

算法是完成一组任务的指令。





### 1.2 二分查找

每次查找中间位置的数，这样就能排除一半的元素，在剩下的元素中继续重复，直到结束。

对于包含n个元素的列表，用二分查找最多需要 log$_{2}$n 步。

输入必须是有序的元素列表。



简单例子

```java
import java.util.List;

public class 二分查找 {

    public static int search(int[] list, int item){
        int low =0;
        int high = list.length - 1;

        while (low <= high){
            int mid = ( low + high ) /2;
            int guess = list[mid];
            if (guess == item){
                return mid;
            }
            if (guess > item){
                high = mid - 1;
            }
            else if (guess < item){
                low = mid - 1;
            }
        }
        return -1;
    };


    public static void main(String[] args) {
        int[] mylist = {1,3,5,6,8,20,101};
        int a = search(mylist,5);
        System.out.println(a);
    }
}

```







### 1.3  大 O 表示法

算法的运行时间用大 O 表示法表示。

 大 O 表示法指了算法最糟糕情况下的运行时间。

算法的运行时间指的是算法需要的操作数。



#### 1.3.1 一些常见的大O运行时间

O(log n) 对数时间，包括二分查找

O(n) 线性时间，包括简单查找

O(n * log n) 快速排序

O(n$^2$) 选择排序

O(n!) 旅行商问题



 

## 二. 排序

https://www.cnblogs.com/onepixel/articles/7674659.html

![img](https://img2018.cnblogs.com/blog/849589/201903/849589-20190306165258970-1789860540.png)

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)



### 2.1 选择排序

#### 2.1.1 概念

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

![选择](https://img-blog.csdn.net/20180607094110661?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNzAzNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



#### 2.1.2代码

```java
function sortArray(arr) {
	for (let i = 0; i < arr.length-1;i++) {
		let pos = i;
		for(let j = i +1; j < arr.length;j++){
			if(arr[pos] > arr[j]){
				pos = j;
			}
		}
		let tmp = arr[i];
			arr[i] = arr[pos];
			arr[pos] = tmp;
	}
}
```



### 2.2 快速排序



### 2.3 归并排序



### 2.4计数排序





## 三. 搜索

### 3.1 递归



### 3.2 剪枝



### 3.3 广度优先搜索

深度优先搜索

### 3.4 狄克斯特拉算法

爬山算法

回溯算法





## 四. 图论

### 4.1 最短路



### 4.2 最小生成树



### 4.3 网络流建模



## 五. 技巧

### 5.1 分而治之



### 5.2 动态规划



### 5.3 贪婪算法



### 5.4 倍增



### 5.5 NP问题



## 六. 其他

### 6.1 K最邻近算法
